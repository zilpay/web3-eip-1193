Project Path: web3-evm

Source Tree:

```
web3-evm
├── test
│   ├── index.html
│   └── server.ts
├── bun.lockb
├── README.md
├── package.json
├── tsconfig.json
├── index.ts
└── src
    ├── types.ts
    └── zilpay-provider.ts

```

`/Users/rinat/projects/zilpay/web3-evm/test/server.ts`:

```ts
const server = Bun.serve({
  port: 8080,
  hostname: '127.0.0.1',
  async fetch(req) {
    const url = new URL(req.url);
    const path = url.pathname;

    try {
      if (path === '/' || path === '/index.html') {
        const html = await Bun.file('./test/index.html').text();
        return new Response(html, {
          headers: { 'Content-Type': 'text/html' }
        });
      } 
      else if (path === '/dist/index.js') {
        const js = await Bun.file('./dist/index.js').text();
        return new Response(js, {
          headers: { 'Content-Type': 'application/javascript' }
        });
      }

      return new Response('Not Found', { status: 404 });
    } catch (error) {
      return new Response('Server Error', { status: 500 });
    }
  }
});

console.log(`Server running at http://${server.hostname}:${server.port}`);

```

`/Users/rinat/projects/zilpay/web3-evm/index.ts`:

```ts
import { ZilPayProviderImpl } from './src/zilpay-provider';

export * from './src/types';
export * from './src/zilpay-provider';

(function() {
  if (typeof window === 'undefined' || !window) {
    console.warn('No window object available for ZilPay injection');
    return;
  }

  try {
    if ('zilPay' in window && window.zilPay) {
      console.warn('ZilPay provider already exists in window');
      return;
    }

    const provider = new ZilPayProviderImpl();

    try {
      Object.defineProperty(window, 'zilPay', {
        value: provider,
        writable: false,
        configurable: true,
      });
    } catch (defineError) {
      (window as any).zilPay = provider;
      console.warn('Using fallback assignment for zilPay due to:', defineError);
    }

    window.dispatchEvent(new Event('zilPay#initialized'));
    console.log('ZilPay provider injected successfully');
  } catch (error) {
    console.error('Failed to inject ZilPay provider:', error);
  }
})();

```

`/Users/rinat/projects/zilpay/web3-evm/src/types.ts`:

```ts

export interface RequestPayload {
  method: string;
  params?: Array<any> | Record<string, any>;
}

export interface ZilPayProvider {
  isZilPay: boolean;
  request(payload: RequestPayload): Promise<any>;
  on(event: string, callback: (...args: any[]) => void): void;
  removeListener(event: string, callback: (...args: any[]) => void): void;
  enable(): Promise<string[]>;
}

export interface ZilPayMethods {
  'requestAccounts': () => Promise<string[]>;
  'getAccounts': () => Promise<string[]>;
  'signMessage': (message: string) => Promise<string>;
  'sendTransaction': (txParams: {
    to: string;
    value: string;
    gasPrice: string;
    gasLimit: string;
    data?: string;
  }) => Promise<string>;
}


declare global {
  interface Window {
    zilPay: ZilPayProvider;
  }
}

```

`/Users/rinat/projects/zilpay/web3-evm/src/zilpay-provider.ts`:

```ts
import type { RequestPayload, ZilPayProvider } from './types';

export class ZilPayProviderImpl implements ZilPayProvider {
  readonly isZilPay: boolean = true;
  #eventListeners: Map<string, Set<(...args: any[]) => void>> = new Map();

  constructor() {
    this.#initializeEvents();
    this.#setupFlutterEventHandler();
  }

  #initializeEvents() {
    this.#eventListeners.set('connect', new Set());
    this.#eventListeners.set('disconnect', new Set());
    this.#eventListeners.set('chainChanged', new Set());
    this.#eventListeners.set('accountsChanged', new Set());
    this.#eventListeners.set('message', new Set());
  }

  #setupFlutterEventHandler() {
    if (typeof window !== 'undefined' && window) {
      (window as any).handleZilPayEvent = (eventData: any) => {
        const listeners = this.#eventListeners.get(eventData.event);
        if (listeners) {
          listeners.forEach(callback => callback(eventData.data));
        }
      };
    }
  }

  async request(payload: RequestPayload): Promise<any> {
    return new Promise((resolve, reject) => {
      const uuid = Math.random().toString(36).substring(2);
      const message = {
        type: 'ZILPAY_REQUEST',
        uuid,
        payload,
      };

      if (typeof window !== 'undefined' && window && (window as any).FlutterWebView) {
        try {
          (window as any).FlutterWebView.postMessage(JSON.stringify(message));
        } catch (e) {
          reject(new Error(`Failed to send request: ${e}`));
          return;
        }
      } else {
        reject(new Error('FlutterWebView channel is not available'));
        return;
      }

      const responseHandler = (eventData: any) => {
        if (
          eventData.type === 'ZILPAY_RESPONSE' &&
          eventData.uuid === uuid
        ) {
          if (eventData.error) {
            reject(new Error(eventData.error));
          } else {
            resolve(eventData.result);
          }
          if (typeof window !== 'undefined' && window) {
            window.removeEventListener('message', responseHandler as any);
          }
        }
      };

      if (typeof window !== 'undefined' && window) {
        window.addEventListener('message', responseHandler as any);
      }
    });
  }

  async enable(): Promise<string[]> {
    return this.request({ method: 'requestAccounts' });
  }

  on(event: string, callback: (...args: any[]) => void): void {
    const listeners = this.#eventListeners.get(event);
    if (listeners) {
      listeners.add(callback);
    }
  }

  removeListener(event: string, callback: (...args: any[]) => void): void {
    const listeners = this.#eventListeners.get(event);
    if (listeners) {
      listeners.delete(callback);
    }
  }
}

```